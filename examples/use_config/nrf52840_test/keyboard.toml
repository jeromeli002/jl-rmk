[keyboard]
name = "jlkb"
product_name = "jlkb Keyboard"
vendor_id = 0x4c4b
product_id = 0x4643
manufacturer = "jlkb"
chip = "nrf52840"

[matrix]
# Row and col pins are mandatory
row_pins = ["P0_04", "P1_09", "P0_08", "P0_05", "P0_06", "P0_26", "P0_30", "P0_31"]
col_pins = ["P0_15", "P0_17", "P0_20", "P0_22", "P1_00", "P1_02", "P1_04", "P1_06", "P0_13", "P0_24"]
# RMK uses col2row as the default matrix diode direction, if you want to use a row2col matrix, add `row2col = true`
# row2col = true

[layout]
rows = 8
cols = 10
layers = 2
matrix_map = """
(0,0) (0,1) (0,2) (0,3) (0,4) (0,5) (0,6) (0,7) (0,8) (0,9)
(1,0) (1,1) (1,2) (1,3) (1,4) (1,5) (1,6) (1,7) (1,8) (1,9)
(2,0) (2,1) (2,2) (2,3) (2,4) (2,5) (2,6) (2,7) (2,8) (2,9)
(3,0) (3,1) (3,2) (3,3) (3,4) (3,5) (3,6) (3,7) (3,8) (3,9)
(4,0) (4,1) (4,2) (4,3) (4,4) (4,5) (4,6) (4,7) (4,8) (4,9)
(5,0) (5,1) (5,2) (5,3) (5,4) (5,5) (5,6) (5,7) (5,8) (5,9)
(6,0) (6,1) (6,2) (6,3) (6,4) (6,5) (6,6) (6,7) (6,8) (6,9)
(7,0) (7,1) (7,2) (7,3) (7,4) (7,5) (7,6) (7,7) (7,8) (7,9)
"""
[[layer]]
name = "base_layer"
keys = """
X X X X X X X X X X 
Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1
Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1
Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1
Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1
Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1
Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1
Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1
"""

[[layer]]
name = "second_layer"
keys = """
Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1
Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1
Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1
Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1
Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1
Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1
Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1
Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1 Kp1
"""

[aliases]
my_copy = "WM(C, LCtrl)"
my_paste = "WM(V, LCtrl)"

[light]
# All light pins are high-active by default, uncomment if you want it to be low-active
capslock.pin = "P1_10"
capslock.low_active = false
# scrolllock.pin = "PA3"
# scrolllock.low_active = true
# Just ignore if no light pin is used for it
# numslock.pin = "PA5"
# numslock.low_active = true

[[input_device.encoder]]
pin_a = "P0_03"
pin_b = "P0_28"

# Whether to use the MCU's internal pull-up resistor, default to false
internal_pullup = false

# Working mode of the encoder
# Available modes:
# - default: resolution = 1
# - resolution: custom resolution, requires specifying resolution and reverse parameters
phase = "resolution"

# `resolution` represents the number of steps generated per detent.
#
# When your encoder datasheet lists:
#   - detent = number of mechanical detent positions  
#   - pulse  = number of full quadrature cycles (A/B cycles)  
#
# Then the relationship is:
#   resolution = (pulse × 4) / detent
# because each full quadrature cycle (pulse) produces 4 edge transitions.
#
# For example — in the ALPS EC11E series(https://tech.alpsalpine.com/cms.media/product_catalog_ec_01_ec11e_en_611f078659.pdf):
#   detent = 30, pulse = 15 → resolution = (15 × 4) / 30 = 2
resolution = 4

# Whether the direction of the rotary encoder is reversed.
reverse = false

[storage]
# Storage feature is enabled by default
# enabled = false
# clear_storage = true

[ble]
enabled = true
# vddh has an internal voltage divider
battery_adc_pin = "vddh"
# Or
# battery_adc_pin = "P0_04"
# adc_divider_measured = 2000
# adc_divider_total = 2806

[behavior.combo]
timeout = "150ms"
combos = [
  # Press J and K keys simultaneously to output "L"
  { actions = ["J", "K"], output = "L" },
  # Press F and D keys simultaneously to switch to layer 2, but only valid on layer 0
  { actions = ["F", "D"], output = "TO(1)", layer = 0 },
  # Three-key combo, press A, S, and D keys to output "X"
  { actions = ["A", "S", "D"], output = "X" }
]

[behavior.fork]
forks = [
    # Shift + '.' output ':' key
  { trigger = "Dot", negative_output = "Dot", positive_output = "WM(Semicolon, LShift)", match_any = "LShift|RShift" },

  # Shift + ',' output ';' key but only if no Alt is pressed
  { trigger = "Comma", negative_output = "Comma", positive_output = "Semicolon", match_any = "LShift|RShift", match_none = "LAlt|RAlt" },  
  
  # left bracket outputs by default '{', with shifts pressed outputs '['  
  { trigger = "LeftBracket", negative_output = "WM(LeftBracket, LShift)", positive_output = "LeftBracket", match_any = "LShift|RShift" },

  # Flip the effect of shift on 'x'/'X'
  { trigger = "X", negative_output = "WM(X, LShift)", positive_output = "X", match_any = "LShift|RShift" },

  # F24 usually outputs 'a', except when Left Shift or Ctrl pressed, in that case triggers a macro 
  { trigger = "F24", negative_output = "A", positive_output = "Macro1", match_any = "LShift|LCtrl" },

  # Swap Z and Y keys if MouseBtn1 is pressed (on the keyboard) (Note that these must not be bindable to avoid infinite fork loops!) 
  { trigger = "Y", negative_output = "Y", positive_output = "Z", match_any = "MouseBtn1", bindable = false },
  { trigger = "Z", negative_output = "Z", positive_output = "Y", match_any = "MouseBtn1", bindable = false },

  # Shift + Backspace output Delete key (inside a layer tap/hold)
  { trigger = "LT(2,Backspace)", negative_output = "LT(2,Backspace)", positive_output = "LT(2,Delete)", match_any = "LShift|RShift" },

  # Ctrl + play/pause will send next track. MediaPlayPause -> MediaNextTrack
  # Ctrl + Shift + play/pause will send previous track. MediaPlayPause -> MediaPrevTrack
  # Alt + play/pause will send volume up. MediaPlayPause -> AudioVolUp
  # Alt + Shift + play/pause will send volume down. MediaPlayPause -> AudioVolDown
  # Ctrl + Alt + play/pause will send brightness up. MediaPlayPause -> BrightnessUp
  # Ctrl + Alt + Shift + play/pause will send brightness down. MediaPlayPause -> BrightnessDown
  # ( Note that the trigger and immediate trigger keys of the fork chain could be 'virtual keys', 
  #   which will never output, like F23, but here multiple overrides demonstrated.)
  { trigger = "MediaPlayPause", negative_output = "MediaPlayPause", positive_output = "MediaNextTrack", match_any = "LCtrl|RCtrl", bindable = true },
  { trigger = "MediaNextTrack", negative_output = "MediaNextTrack", positive_output = "BrightnessUp", match_any = "LAlt|RAlt", bindable = true },
  { trigger = "BrightnessUp", negative_output = "BrightnessUp", positive_output = "BrightnessDown", match_any = "LShift|RShift", bindable = false },
  { trigger = "MediaNextTrack", negative_output = "MediaNextTrack", positive_output = "MediaPrevTrack", match_any = "LShift|RShift", match_none = "LAlt|RAlt", bindable = false},
  { trigger = "MediaPlayPause", negative_output = "MediaPlayPause", positive_output = "AudioVolUp", match_any = "LAlt|RAlt", match_none = "LCtrl|RCtrl", bindable = true },
  { trigger = "AudioVolUp", negative_output = "AudioVolUp", positive_output = "AudioVolDown", match_any = "LShift|RShift", match_none = "LCtrl|RCtrl", bindable = false } 
]

[rmk]
combo_max_num = 128 
fork_max_num = 16
